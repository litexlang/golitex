# 向量是某个向量空间（V, F, +, *）的元素，V是一个集合，配备了满足向量定义的加法和属于域F的标量乘法运算
# 二维向量空间，即平面，它的V是cart(R, R)，F是R，+和*是普通的向量和参数乘法

have fn:
    vector_add(a cart(R, R), b cart(R, R)) cart(R, R):
        vector_add(a, b) = (a[1] + b[1], a[2] + b[2])

    prove:
        have c cart(R, R) = (a[1] + b[1], a[2] + b[2])
    = c

have fn:
    vector_minus(a cart(R, R), b cart(R, R)) cart(R, R):
        vector_minus(a, b) = (a[1] - b[1], a[2] - b[2])

    prove:
        have c cart(R, R) = (a[1] - b[1], a[2] - b[2])
    = c

have fn:
    vector_scalar_multiply(a R, b cart(R, R)) cart(R, R):
        vector_scalar_multiply(a, b) = (a * b[1], a * b[2])

    prove:
        have c cart(R, R) = (a * b[1], a * b[2])
    = c

have fn:
    vector_module(a cart(R, R)) R:
        vector_module(a) = sqrt(a[1]^2 + a[2]^2)

    prove:
        a[1]^ 2 >= 0
        a[2]^ 2 >= 0
        a[1]^2 + a[2]^2 >= 0
        have c R = sqrt(a[1]^2 + a[2]^2)
    = c

have fn:
    vector_dot_product(a cart(R, R), b cart(R, R)) R:
        vector_dot_product(a, b) = a[1] * b[1] + a[2] * b[2]

    prove:
        have c R = a[1] * b[1] + a[2] * b[2]
    = c

# TODO: 两个向量的夹角

prop is_unit_vector(a cart(R, R)):
    vector_module(a) = 1

have fn:
    vector_scalar_projection(a cart(R, R), b cart(R, R)) R:
        dom:
            vector_module(b) != 0
        =>:
            vector_scalar_projection(a, b) = vector_dot_product(a, b) / (vector_module(b) * vector_module(b))
    prove:
        vector_module(b) * vector_module(b) > 0
        have c R = vector_dot_product(a, b) / (vector_module(b) * vector_module(b))
    = c

have fn:
    vector_projection(a cart(R, R), b cart(R, R)) cart(R, R):
        dom:
            vector_module(b) != 0
        =>:
            vector_module(b) * vector_module(b) > 0
            vector_projection(a, b) = vector_scalar_multiply(vector_dot_product(a, b) / (vector_module(b) * vector_module(b)), b) = vector_scalar_multiply(vector_scalar_projection(a, b), b)
    prove:
        have c cart(R, R) = vector_scalar_multiply(vector_dot_product(a, b) / (vector_module(b) * vector_module(b)), b)
    = c

prop is_zero_vector(a cart(R, R)):
    a[1] = 0
    a[2] = 0

prop are_parallel_vectors(a cart(R, R), b cart(R, R)):
    vector_dot_product(a, b) = vector_module(a) * vector_module(b)

prop are_equal_vectors(a cart(R, R), b cart(R, R)):
    a[1] = b[1]
    a[2] = b[2]

prop are_orthogonal_vectors(a cart(R, R), b cart(R, R)):
    vector_dot_product(a, b) = 0

prop are_inverse_vectors(a cart(R, R), b cart(R, R)):
    a[1] = -b[1]
    a[2] = -b[2]

exist_prop a, b R st can_be_bases_of_vector(c, d, e cart(R, R)):
    e = vector_scalar_multiply(a, c) + vector_scalar_multiply(b, d)

prop are_bases_vectors(a cart(R, R), b cart(R, R)):
    forall c cart(R, R) => $can_be_bases_of_vector(a, b, c)
    
# 举例：a = (1, 2), b = (3, 4)
prove:
    have a cart(R, R) = (1, 2)
    have b cart(R, R) = (3, 4)
    vector_add(a, b) = (1 + 3, 2 + 4) = (4, 6)
    vector_scalar_multiply(2, b) = (2 * 3, 2 * 4) = (6, 8)
