have U nonempty_set
have nil U
fn l(p U) U => l(nil) = nil
fn r(p U) U => r(nil) = nil
fn cons(x U, y U) U => l(cons(x,y))=x, r(cons(x,y))=y, cons(x, y) != nil
know @cons_is_unique(x0,y0,x1,y1 obj): cons(x0, y0) = cons(x1, y1) => x0 = x1, y0 = y1

# important properties
# every element in U is either nil or a cons of something

exist_prop x,y obj st has_lr(p U):
    cons(x, y) = p
know forall p U: p != nil => $has_lr(p)


fn nth(x N_pos, p U) U
know:
    forall p U => nth(1, p) = l(p)
    forall x N_pos, p U: x > 1 => nth(x, p) = nth(x-1, r(p))

algo table_nth(x, p):
    if x = 1:
        return l(p)
    if x > 1:
        nth(x, p) = nth(x-1, r(p))
        return table_nth(x-1, r(p))

have px U
by table_nth(2, px)
nth(2, px) = l(r(px)) # this works

by table_nth(3, px)
nth(3, px) = nth(2, r(px))
nth(3, px) = l(r(r(px))) # but this does not work
by table_nth(4, px)
nth(4, px) = l(r(r(r(px)))) # neither does this