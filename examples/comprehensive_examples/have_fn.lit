# 向量是某个向量空间（V, F, +, *）的元素，V是一个集合，配备了满足向量定义的加法和属于域F的标量乘法运算
# 二维向量空间，即平面，它的V是cart(R, R)，F是R，+和*是普通的向量和参数乘法

have fn:
    vadd(a cart(R, R), b cart(R, R)) cart(R, R):
        vadd(a, b) = (a[1] + b[1], a[2] + b[2])

    prove:
        have c cart(R, R) = (a[1] + b[1], a[2] + b[2])
    = c

have fn:
    vsub(a cart(R, R), b cart(R, R)) cart(R, R):
        vsub(a, b) = (a[1] - b[1], a[2] - b[2])

    prove:
        have c cart(R, R) = (a[1] - b[1], a[2] - b[2])
    = c

have fn:
    vsm(a R, b cart(R, R)) cart(R, R):
        vsm(a, b) = (a * b[1], a * b[2])

    prove:
        have c cart(R, R) = (a * b[1], a * b[2])
    = c

have fn:
    vmod(a cart(R, R)) R:
        vmod(a) = sqrt(a[1]^2 + a[2]^2)

    prove:
        a[1]^ 2 >= 0
        a[2]^ 2 >= 0
        a[1]^2 + a[2]^2 >= 0
        have c R = sqrt(a[1]^2 + a[2]^2)
    = c

have fn:
    vp(a cart(R, R), b cart(R, R)) R:
        vp(a, b) = a[1] * b[1] + a[2] * b[2]

    prove:
        have c R = a[1] * b[1] + a[2] * b[2]
    = c

# TODO: 两个向量的夹角

prop is_unit_vector(a cart(R, R)):
    vmod(a) = 1

have fn:
    vsp(a cart(R, R), b cart(R, R)) R:
        dom:
            vmod(b) != 0
        =>:
            vsp(a, b) = vp(a, b) / (vmod(b) * vmod(b))
    prove:
        vmod(b) * vmod(b) > 0
        have c R = vp(a, b) / (vmod(b) * vmod(b))
    = c

have fn:
    vproj(a cart(R, R), b cart(R, R)) cart(R, R):
        dom:
            vmod(b) != 0
        =>:
            vmod(b) * vmod(b) > 0
            vproj(a, b) = vsm(vp(a, b) / (vmod(b) * vmod(b)), b) = vsm(vsp(a, b), b)
    prove:
        have c cart(R, R) = vsm(vp(a, b) / (vmod(b) * vmod(b)), b)
    = c

prop is_zero_vector(a cart(R, R)):
    a[1] = 0
    a[2] = 0

prop are_parallel_vectors(a cart(R, R), b cart(R, R)):
    vp(a, b) = vmod(a) * vmod(b)

prop are_equal_vectors(a cart(R, R), b cart(R, R)):
    a[1] = b[1]
    a[2] = b[2]

prop are_orthogonal_vectors(a cart(R, R), b cart(R, R)):
    vp(a, b) = 0

prop are_inverse_vectors(a cart(R, R), b cart(R, R)):
    a[1] = -b[1]
    a[2] = -b[2]

exist_prop a, b R st can_be_bases_of_vector(c, d, e cart(R, R)):
    e = vsm(a, c) + vsm(b, d)

prop are_bases_vectors(a cart(R, R), b cart(R, R)):
    forall c cart(R, R) => $can_be_bases_of_vector(a, b, c)
    
# 加法交换律
prove forall a, b cart(R, R) => vadd(a, b) = vadd(b, a):
    vadd(a, b) = (a[1] + b[1], a[2] + b[2]) = (b[1] + a[1], b[2] + a[2]) = vadd(b, a)

# 加法结合律
prove forall a, b, c cart(R, R) => vadd(vadd(a, b), c) = vadd(a, vadd(b, c)):
    vadd(vadd(a, b), c) = (vadd(a, b)[1] + c[1], vadd(a, b)[2] + c[2])
    vadd(a, b)[1] = (a[1] + b[1], a[2] + b[2])[1] = a[1] + b[1]
    vadd(a, b)[2] = (a[1] + b[1], a[2] + b[2])[2] = a[2] + b[2]
    vadd(vadd(a, b), c) = (a[1] + b[1] + c[1], a[2] + b[2] + c[2])
    vadd(b, c)[1] = (b[1] + c[1], b[2] + c[2])[1] = b[1] + c[1]
    vadd(b, c)[2] = (b[1] + c[1], b[2] + c[2])[2] = b[2] + c[2]
    vadd(a, vadd(b, c)) = (a[1] + vadd(b, c)[1], a[2] + vadd(b, c)[2]) = (a[1] + (b[1] + c[1]), a[2] + (b[2] + c[2])) = (a[1] + b[1] + c[1], a[2] + b[2] + c[2])
    vadd(vadd(a, b), c) = vadd(a, vadd(b, c))

# 参数乘法结合律 (a * b) v = a (b v)
prove forall a, b R, v cart(R, R) => vsm(a * b, v) = vsm(a, vsm(b, v)):
    vsm(a * b, v) = (a * b * v[1], a * b * v[2]) = (a * (b * v[1]), a * (b * v[2]))
    b * v[1] = (b * v[1], b * v[2])[1] = b * v[1]
    b * v[2] = (b * v[1], b * v[2])[2] = b * v[2]
    
    vsm(a, vsm(b, v)) = vsm(a, (b * v[1], b * v[2])) = (a * (b * v[1], b * v[2])[1], a * (b * v[1], b * v[2])[2]) = (a * b * v[1], a * b * v[2]) = vsm(a * b, v)

# 参数乘法交换率 (a * b) v = (b * a) v
prove forall a, b R, v cart(R, R) => vsm(a * b, v) = vsm(b * a, v):
    vsm(a * b, v) = (a * b * v[1], a * b * v[2]) = vsm(b * a, v)

# 点积分配律 a (b + c) = a b + a c
prove forall a, b, c cart(R, R) => vp(a, vadd(b, c)) = vp(a, b) + vp(a, c):
    vadd(b, c)[1] = (b[1] + c[1], b[2] + c[2])[1] = b[1] + c[1]
    vadd(b, c)[2] = (b[1] + c[1], b[2] + c[2])[2] = b[2] + c[2]

    # TODO：或许在内核里可以支持一下，如果函数返回值是cart，然后想要知道某一位的值在某个集合里，那就看看函数返回值的对应位的集合是不是在那个集合里；就不用每次手写一下了
    vadd(b, c) $in cart(R, R)
    
    vp(a, vadd(b, c)) = a[1] * vadd(b, c)[1] + a[2] * vadd(b, c)[2] = a[1] * (b[1] + c[1]) + a[2] * (b[2] + c[2]) = a[1] * b[1] + a[1] * c[1] + a[2] * b[2] + a[2] * c[2] = (a[1] * b[1] + a[2] * b[2]) + (a[1] * c[1] + a[2] * c[2]) = vp(a, b) + vp(a, c)

# TODO: 向量基本定理：如果两个向量不平行，那么它们可以作为某个向量空间的基底

# TODO: 向量正交分解
    
# 举例：a = (1, 2), b = (3, 4)
prove:
    have a cart(R, R) = (1, 2)
    have b cart(R, R) = (3, 4)
    vadd(a, b) = (1 + 3, 2 + 4) = (4, 6)
    vsm(2, b) = (2 * 3, 2 * 4) = (6, 8)
