# 向量是某个向量空间（V, F, +, *）的元素，V是一个集合，配备了满足向量定义的加法和属于域F的标量乘法运算
# 二维向量空间，即平面，它的V是cart(R, R)，F是R，+和*是普通的向量和参数乘法

have fn:
    add(a cart(R, R), b cart(R, R)) cart(R, R):
        add(a, b) = (a[1] + b[1], a[2] + b[2])

    prove:
        have c cart(R, R) = (a[1] + b[1], a[2] + b[2])
    = c

have fn:
    sub(a cart(R, R), b cart(R, R)) cart(R, R):
        sub(a, b) = (a[1] - b[1], a[2] - b[2])

    prove:
        have c cart(R, R) = (a[1] - b[1], a[2] - b[2])
    = c

have fn:
    sm(a R, b cart(R, R)) cart(R, R):
        sm(a, b) = (a * b[1], a * b[2])

    prove:
        have c cart(R, R) = (a * b[1], a * b[2])
    = c

have fn:
    mod(a cart(R, R)) R:
        mod(a) = sqrt(a[1]^2 + a[2]^2)

    prove:
        a[1]^ 2 >= 0
        a[2]^ 2 >= 0
        a[1]^2 + a[2]^2 >= 0
        have c R = sqrt(a[1]^2 + a[2]^2)
    = c

have fn:
    prod(a cart(R, R), b cart(R, R)) R:
        prod(a, b) = a[1] * b[1] + a[2] * b[2]

    prove:
        have c R = a[1] * b[1] + a[2] * b[2]
    = c

# TODO: 两个向量的夹角，三角函数
have fn:
    cos(a cart(R, R), b cart(R, R)) R:
        dom:
            mod(a) != 0
            mod(b) != 0
        =>:
            cos(a, b) = prod(a, b) / (mod(a) * mod(b))
    prove:
        have c R = prod(a, b) / (mod(a) * mod(b))
    = c

have fn:
    sin(a cart(R, R), b cart(R, R)) R:
        dom:
            mod(a) != 0
            mod(b) != 0
        =>:
            sin(a, b) = (a[1] * b[2] - a[2] * b[1]) / (mod(a) * mod(b))
    prove:
        have c R = (a[1] * b[2] - a[2] * b[1]) / (mod(a) * mod(b))
    = c

have fn:
    tan(a cart(R, R), b cart(R, R)) R:
        dom:
            mod(a) != 0
            mod(b) != 0
            cos(a, b) != 0
        =>:
            tan(a, b) = sin(a, b) / cos(a, b)
    prove:
        have c R = sin(a, b) / cos(a, b)
    = c

have fn:
    cot(a cart(R, R), b cart(R, R)) R:
        dom:
            mod(a) != 0
            mod(b) != 0
            sin(a, b) != 0
        =>:
            cot(a, b) = cos(a, b) / sin(a, b)
    prove:
        have c R = cos(a, b) / sin(a, b)
    = c

prop is_unit_vector(a cart(R, R)):
    mod(a) = 1

have fn:
    vsp(a cart(R, R), b cart(R, R)) R:
        dom:
            mod(b) != 0
        =>:
            vsp(a, b) = prod(a, b) / (mod(b) * mod(b))
    prove:
        mod(b) * mod(b) > 0
        have c R = prod(a, b) / (mod(b) * mod(b))
    = c

have fn:
    project(a cart(R, R), b cart(R, R)) cart(R, R):
        dom:
            mod(b) != 0
        =>:
            mod(b) * mod(b) > 0
            project(a, b) = sm(prod(a, b) / (mod(b) * mod(b)), b) = sm(vsp(a, b), b)
    prove:
        have c cart(R, R) = sm(prod(a, b) / (mod(b) * mod(b)), b)
    = c

prop is_zero_vector(a cart(R, R)):
    a[1] = 0
    a[2] = 0

prop are_equal_vectors(a cart(R, R), b cart(R, R)):
    a[1] = b[1]
    a[2] = b[2]

prop are_orthogonal_vectors(a cart(R, R), b cart(R, R)):
    prod(a, b) = 0

prop are_inverse_vectors(a cart(R, R), b cart(R, R)):
    a[1] = -b[1]
    a[2] = -b[2]

exist_prop a, b R st can_be_bases_of_vector(c, d, e cart(R, R)):
    e = sm(a, c) + sm(b, d)

prop are_bases_vectors(a cart(R, R), b cart(R, R)):
    forall c cart(R, R) => $can_be_bases_of_vector(a, b, c)
    
# 加法交换律
prove forall a, b cart(R, R) => add(a, b) = add(b, a):
    add(a, b) = (a[1] + b[1], a[2] + b[2]) = (b[1] + a[1], b[2] + a[2]) = add(b, a)

# 加法结合律
prove forall a, b, c cart(R, R) => add(add(a, b), c) = add(a, add(b, c)):
    add(add(a, b), c) = (add(a, b)[1] + c[1], add(a, b)[2] + c[2])
    add(a, b)[1] = (a[1] + b[1], a[2] + b[2])[1] = a[1] + b[1]
    add(a, b)[2] = (a[1] + b[1], a[2] + b[2])[2] = a[2] + b[2]
    add(add(a, b), c) = (a[1] + b[1] + c[1], a[2] + b[2] + c[2])
    add(b, c)[1] = (b[1] + c[1], b[2] + c[2])[1] = b[1] + c[1]
    add(b, c)[2] = (b[1] + c[1], b[2] + c[2])[2] = b[2] + c[2]
    add(a, add(b, c)) = (a[1] + add(b, c)[1], a[2] + add(b, c)[2]) = (a[1] + (b[1] + c[1]), a[2] + (b[2] + c[2])) = (a[1] + b[1] + c[1], a[2] + b[2] + c[2])
    add(add(a, b), c) = add(a, add(b, c))

# 参数乘法结合律 (a * b) v = a (b v)
prove forall a, b R, v cart(R, R) => sm(a * b, v) = sm(a, sm(b, v)):
    sm(a * b, v) = (a * b * v[1], a * b * v[2]) = (a * (b * v[1]), a * (b * v[2]))
    b * v[1] = (b * v[1], b * v[2])[1] = b * v[1]
    b * v[2] = (b * v[1], b * v[2])[2] = b * v[2]
    
    sm(a, sm(b, v)) = sm(a, (b * v[1], b * v[2])) = (a * (b * v[1], b * v[2])[1], a * (b * v[1], b * v[2])[2]) = (a * b * v[1], a * b * v[2]) = sm(a * b, v)

# 参数乘法交换率 (a * b) v = (b * a) v
prove forall a, b R, v cart(R, R) => sm(a * b, v) = sm(b * a, v):
    sm(a * b, v) = (a * b * v[1], a * b * v[2]) = sm(b * a, v)

# 点积分配律 a (b + c) = a b + a c
prove forall a, b, c cart(R, R) => prod(a, add(b, c)) = prod(a, b) + prod(a, c):
    add(b, c)[1] = (b[1] + c[1], b[2] + c[2])[1] = b[1] + c[1]
    add(b, c)[2] = (b[1] + c[1], b[2] + c[2])[2] = b[2] + c[2]

    add(b, c) $in cart(R, R)
    
    prod(a, add(b, c)) = a[1] * add(b, c)[1] + a[2] * add(b, c)[2] = a[1] * (b[1] + c[1]) + a[2] * (b[2] + c[2]) = a[1] * b[1] + a[1] * c[1] + a[2] * b[2] + a[2] * c[2] = (a[1] * b[1] + a[2] * b[2]) + (a[1] * c[1] + a[2] * c[2]) = prod(a, b) + prod(a, c)

# TODO: 向量基本定理：如果两个向量不平行，那么它们可以作为某个向量空间的基底

have fn:
    orth_decomp(a cart(R, R), e1 cart(R, R), e2 cart(R, R)) cart(R, R):
        dom:
            mod(e1) != 0
            mod(e2) != 0
            $are_orthogonal_vectors(e1, e2)
        =>:
            orth_decomp(a, e1, e2)[1] = mod(project(a, e1))
            orth_decomp(a, e1, e2)[2] = mod(project(a, e2))
    prove:
        have c cart(R, R) = (mod(project(a, e1)), mod(project(a, e2)))
    = c
    
prove:
    # 举例：a = (1, 2), b = (3, 4)
    have a cart(R, R) = (1, 2)
    have b cart(R, R) = (3, 4)
    add(a, b) = (1 + 3, 2 + 4) = (4, 6)
    sm(2, b) = (2 * 3, 2 * 4) = (6, 8)

know forall a, b, c, d cart(R, R) => (a, b) \add (c, d) = (a + c, b + d)