"""
Chapter 6
"""

import "util.lit"
import "basics.lit"
import "chap1.lit"
import "chap2.lit"
import "chap3.lit"
import "chap4.lit"
import "chap5.lit"

# Definition 6.1
# Definition of ring
prop is_unary_ring(ring set, add fn(ring, ring)ring, mul fn(ring, ring)ring, inv fn(ring)ring, add_e ring, mul_e ring):
    $is_commutative_group(ring, add, inv, add_e)
    forall a ring, b ring, c ring:
        add(mul(a, b), mul(a, c)) = mul(a, add(b, c))
        mul(a, mul(b, c)) = mul(mul(a, b), c)
        mul(a, b) = mul(b, a)
    forall a ring:
        mul(a, mul_e) = a
        mul(mul_e, a) = a


# Definition of cc_mul
fn cc_mul(m Z) fn(cc_mod(m), cc_mod(m))cc_mod(m):
    m > 0
    =>:
        forall x N, y N:
            x < m
            y < m
            =>:
                cc(x * y, m) = cc(x, m) \cc_mul(m) cc(y, m)

# Theorem 6.1
# For any integer m > 0, the set cc(m) is a unary ring under addition and multiplication modulo m
know:
    forall m Z:
        m > 0
        =>:
            $is_unary_ring(cc_mod(m), cc_add(m), cc_mul(m), cc_inv(m), cc(0, m), cc(1, m))

# Theorem 6.2
# Let m, a, b be with m > 0, put d = gcd(a,m), then the congruence ax = b (mod m) has either exactly d solutions modulo m, or no solution; it has a solution iff b = 0 (mod d); there are exactly m/d distinct values of b modulo m for which this is so.

set_fn solutions_of_congruence(a Z, b Z, m Z) x Z:
    $is_congruent_modulo(a * x, b, m)

set_fn solutions_of_congruence_modulo(a Z, b Z, m Z) x Z:
    x >= 0
    x < m
    $is_congruent_modulo(a * x, b, m)

forall a Z, b Z, m Z:
    $int_set_has_lower_bound_and_upper_bound_is_finite(solutions_of_congruence_modulo(a, b, m), 0, m)
    solutions_of_congruence_modulo(a, b, m) $in finite_set

prop solutions_of_congruence_is_finite(a Z, b Z, m Z):
    or:
        len(solutions_of_congruence_modulo(a, b, m)) = 0
        len(solutions_of_congruence_modulo(a, b, m)) = gcd(a, m)

set_fn distinct_solutions_of_congruence(a Z, b Z, m Z) x Z:
    dom:
        len(solutions_of_congruence_modulo(a, b, m)) = gcd(a, m)
    <=>:
        x >= 0 
        x < m
        $is_congruent_modulo(a * x, b, m)

forall a Z, b Z, m Z:
    $int_set_has_lower_bound_and_upper_bound_is_finite(distinct_solutions_of_congruence(a, b, m), 0, m)
    distinct_solutions_of_congruence(a, b, m) $in finite_set

know:
    forall a Z, b Z, m Z:
        len(distinct_solutions_of_congruence(a, b, m)) = m / (gcd(a, m))

fn euler_phi(m Z) Z:
    len(cc_prime_to(m))
    
# Corollary 6.1
# The congruence classes prime to m modulo m make up a group under multiplication
fn cc_prime_to(m Z) finite_set:
    forall x cc_prime_to(m):
        x $in cc_mod(m)
        $is_cc_prime_to_modulo(m, x)
    forall x Z:
        gcd(x, m) = 1
        =>:
            cc(x, m) $in cc_prime_to(m)

# Definition 6.3
# Definition of field
prop is_field(field set, add fn(field, field)field, mul fn(field, field)field, inv fn(field)field, add_e field, mul_e field, mul_inv fn(field)field):
    $is_commutative_ring(field, add, mul, inv, add_e, mul_e)
    forall a field, b field, c field:
        a != add_e
        b != add_e
        c != add_e
        =>:
            mul(a, mul_inv(b)) = mul_e
            mul(b, mul_inv(a)) = mul_e

# Here we directly assume such a function exists. it can actually be proved. To formalize existence of such a function, we use exist_prop.
exist_prop inv_fn fn(cc_mod(m))cc_mod(m) cc_mul_inv_exists(m Z):
    m > 1
    <=>:
        forall x cc_mod(m):
            x != cc(0, m)
            =>:
                cc_mul(m)(x) \cc_mul(m) inv_fn(cc_mul(m)(x)) = cc(1, m)
                inv_fn(cc_mul(m)(x)) \cc_mul(m) cc_mul(m)(x) = cc(1, m)

prop cc_mul_inv_exists_unique(m Z, f fn(cc_mod(m))cc_mod(m), g fn(cc_mod(m))cc_mod(m)):
    m > 1
    m $is_prime
    exist f $cc_mul_inv_exists(m)
    exist g $cc_mul_inv_exists(m)
    =>:
        f = g

know:
    # Existence of multiplicative inverse in a field generated by a prime number
    forall m Z:
        m > 1
        m $is_prime
        =>:
            $cc_mul_inv_exists(m)

    # Uniqueness of multiplicative inverse in a field generated by a prime number
    forall m Z, f fn(cc_mod(m))cc_mod(m), g fn(cc_mod(m))cc_mod(m):
        m > 1
        m $is_prime
        =>:
            $cc_mul_inv_exists_unique(m, f, g)

have cc_mul_inv $cc_mul_inv_exists(m)

# Theorem 6.3
know:
    forall m Z:
        m > 1
        =>:
            m $is_prime
        <=>:
            $is_field(cc_mod(m), cc_add(m), cc_mul(m), cc_inv(m), cc(0, m), cc(1, m), cc_mul_inv(m))