# Litex 多项式自动标准化

Litex 会自动把多项式整理成标准形式（canonical form），以便让用户方便地证明等式。比如：
```
(x + 1) * (x + 2) = x^2 + 3 * x + 2
```

这个功能非常重要。如果这些功能不放在内核里，那这些最最基本的计算，也要用 forall + 匹配和替换 的方式去证明，会非常冗余。

## Litex 内核证明多项式相等的方式

### 1. 单项式内部的标准化规则

#### 1.1 系数位置：系数永远放在最前面
```
x * 2       →  2 * x
y * 3 * z   →  3 * y * z
```

#### 1.2 系数为 1 时省略
```
1 * x       →  x
1 * x * y   →  x * y
```

#### 1.3 系数为 0 时整个项消除
```
0 * x       →  0
0 * x * y   →  0
x + 0 * y   →  x
```

#### 1.4 变量按字典序排列（升序）
```
z * x * y           →  x * y * z
b * a * c           →  a * b * c
z * x * y * a * b   →  a * b * x * y * z
```

#### 1.5 相同变量合并成幂次
```
x * x               →  x^2
x * x * y * x       →  x^3 * y
z * z * x * y * x   →  x^2 * y * z^2
```

#### 1.6 幂次为 1 时省略指数
```
x^1         →  x
x^1 * y^2   →  x * y^2
```

#### 1.7 综合示例
```
z^2 * x * y * x     →  x^2 * y * z^2
2 * z * x * y * 3   →  6 * x * y * z
x * 1 * y           →  x * y
0 * x * y           →  0
y * x * 2 * x       →  2 * x^2 * y
```

### 2. 多项式的项之间的排序规则

#### 2.1 合并同类项
将相同变量和指数的项合并，比如：
```
x^2 + 2*x^3 + 3*x^2     →  2*x^3 + 4*x^2
2*x*y + 3*x*y - x*y     →  4*x*y
```

#### 2.2 按总指数（degree）从大到小排序
先比较每一项的总指数，指数大的排在前面，比如：
```
x + 2*x^3 + x^2         →  2*x^3 + x^2 + x
1 + x + x^2 + x^3       →  x^3 + x^2 + x + 1
```

#### 2.3 总指数相同时，按字典序（lexicographic order）排列
当多个项的总指数相同时，按变量的字典序排列（UTF-8字符串比较）：
- 逐位比较变量名
- 对于每个变量，在单项式内按指数从大到小排列
- 单项式之间按字典序比较

**示例：**
```
x^4 + x^2*y^2 + x + y^4 + y^3 + y
```
标准化后（总指数相同时按字典序）：
```
x^4 + x^2*y^2 + y^4 + y^3 + x + y
```

解释：
- `x^4`: 总指数 4
- `x^2*y^2`: 总指数 4，与 x^4 同级，但按字典序 "x" < "y"，所以 x^2*y^2 排在 y^4 前面
- `y^4`: 总指数 4
- `y^3`: 总指数 3
- `x`: 总指数 1，"x" < "y"（字典序）
- `y`: 总指数 1

### 3. 展开和标准化
自动展开括号并标准化，确保数学上相等的多项式字符串表示完全一致：
```
(x + y)^2                       →  x^2 + 2*x*y + y^2
(x + 1) * (x + 2)              →  x^2 + 3*x + 2
(2*x + 3*y) * (x - y)          →  2*x^2 + x*y - 3*y^2
```

### 4. 复杂符号（函数调用、包名等）的处理

#### 4.1 函数调用作为不可化简的符号
当遇到函数调用（如 `f(x*2)`）时，将整个函数调用视为一个**原子符号（atomic symbol）**，不对其内部进行化简：

```
f(x*2) * 2 + 1.1 * f(x*2)    →  3.1 * f(x*2)
g(y+1) * x + 2 * g(y+1) * x  →  3 * g(y+1) * x
```

**说明**：
- `f(x*2)` 整体作为一个符号，不会化简成 `f(2*x)`
- 多个相同的函数调用可以合并同类项
- 函数调用内部的表达式保持原样

#### 4.2 包名前缀的处理
带包名前缀的符号（如 `pkgName::f(x)` 或 `pkgName::x`）也作为完整的符号处理：

```
pkgName::f(x) * 2           →  2 * pkgName::f(x)
pkgName::x * pkgName2::y    →  pkgName2::y * pkgName::x  (按字典序)
```

**说明**：
- `::` 只是包名的一部分，不影响符号的整体性
- 排序时，将整个 `pkgName::symbolName` 作为字符串进行字典序比较

#### 4.3 复杂符号的排序规则
所有复杂符号（函数调用、带包名的符号等）按照其**字符串形式的字典序**排列：

```
输入：  g(x) * f(x) * z * a(y)
排序：  a(y) * f(x) * g(x) * z
       (按字符串字典序：'a' < 'f' < 'g' < 'z')

输入：  pkgB::x * pkgA::y * x
排序：  pkgA::y * pkgB::x * x
       (按字符串字典序：'p'...'A' < 'p'...'B' < 'x')
```

#### 4.4 混合场景示例

**示例 1：函数调用与普通变量混合**
```
输入：  f(x*2) * y * 2 + x * f(x*2) * 3
化简：  2 * f(x*2) * y + 3 * f(x*2) * x
排序：  3 * f(x*2) * x + 2 * f(x*2) * y
       (f(x*2) 作为整体，x < y 字典序)
```

**示例 2：包名、函数调用、普通变量混合**
```
输入：  pkg::f(x) * z * 2 + pkg::f(x) * a
化简：  2 * pkg::f(x) * z + pkg::f(x) * a
排序：  pkg::f(x) * a + 2 * pkg::f(x) * z
       (同一个符号 pkg::f(x)，变量 a < z)
```

**示例 3：不同函数调用合并**
```
输入：  f(x*2) * 2 + 1.1 * f(x*2) + g(y) * f(x*2)
化简：  3.1 * f(x*2) + f(x*2) * g(y)
排序：  3.1 * f(x*2) + f(x*2) * g(y)
       (纯系数项在前，含其他变量项在后)
```

**示例 4：嵌套复杂度**
```
输入：  pkg2::g(pkg1::f(x)) * 2 + pkg2::g(pkg1::f(x))
化简：  3 * pkg2::g(pkg1::f(x))
       (整个嵌套调用作为一个符号)
```

### 5. 综合复杂示例

#### 示例 1：混合排序和合并
```
输入：  y * 2 * x + z * x * 3 + x * y * 1 + 0 * w
标准化：2*x*y + 3*x*z + x*y
合并：  3*x*y + 3*x*z
```

#### 示例 2：幂次合并
```
输入：  z^2 * x * y * x * 2
标准化：2 * x * x * y * z^2
      = 2 * x^2 * y * z^2
```

#### 示例 3：复杂多项式
```
输入：  (z + x + y) * (z + x + y)
展开：  z*z + z*x + z*y + x*z + x*x + x*y + y*z + y*x + y*y
标准化：z^2 + 2*x*z + x^2 + 2*y*z + 2*x*y + y^2
排序：  z^2 + x^2 + y^2 + 2*x*z + 2*x*y + 2*y*z
```

#### 示例 4：终极综合示例（所有规则的综合应用）

**场景**：包含普通变量、函数调用、包名、系数、幂次等所有元素

```
输入表达式：
  z * f(x*2) * 2 + y * x * 0 + pkg::g(a) * x * 3 
  + f(x*2) * z * 1.5 + x * x * pkg::g(a) 
  + b * a * 1 + pkg::g(a) * 0.5 * x

步骤分解：

步骤 1：处理每一项的系数和变量顺序
  - z * f(x*2) * 2       → 2 * f(x*2) * z
  - y * x * 0            → 0                    (消除)
  - pkg::g(a) * x * 3    → 3 * pkg::g(a) * x
  - f(x*2) * z * 1.5     → 1.5 * f(x*2) * z
  - x * x * pkg::g(a)    → pkg::g(a) * x^2
  - b * a * 1            → a * b                (1被省略，按字典序)
  - pkg::g(a) * 0.5 * x  → 0.5 * pkg::g(a) * x

步骤 2：合并同类项
  - 2 * f(x*2) * z + 1.5 * f(x*2) * z           → 3.5 * f(x*2) * z
  - 3 * pkg::g(a) * x + 0.5 * pkg::g(a) * x    → 3.5 * pkg::g(a) * x
  - pkg::g(a) * x^2                             → pkg::g(a) * x^2
  - a * b                                        → a * b

步骤 3：按总指数和字典序排序
  整理后的项：
    1. pkg::g(a) * x^2      (总指数2，含pkg::g(a)和x)
    2. 3.5 * f(x*2) * z     (总指数1，含f(x*2)和z)
    3. 3.5 * pkg::g(a) * x  (总指数1，含pkg::g(a)和x)
    4. a * b                (总指数2，纯变量)
  
  排序逻辑：
    - 先按总指数：2 > 1
    - 总指数为2的项：pkg::g(a) * x^2 vs a * b
      * 比较字符串："pkg::g(a)" > "a"，所以 a * b 在前
    - 总指数为1的项：f(x*2) * z vs pkg::g(a) * x
      * 比较字符串："f" < "p"，所以 f(x*2) * z 在前

最终标准化结果：
  a * b + pkg::g(a) * x^2 + 3.5 * f(x*2) * z + 3.5 * pkg::g(a) * x
```

#### 示例 5：超级复杂的嵌套场景

```
输入表达式：
  (pkg1::f(x) + 2) * (pkg1::f(x) + 3) + pkg2::g(y*2) * pkg1::f(x)

步骤 1：展开括号
  = pkg1::f(x) * pkg1::f(x) + pkg1::f(x) * 3 + 2 * pkg1::f(x) + 2 * 3 + pkg2::g(y*2) * pkg1::f(x)
  = pkg1::f(x)^2 + 3 * pkg1::f(x) + 2 * pkg1::f(x) + 6 + pkg2::g(y*2) * pkg1::f(x)

步骤 2：合并同类项
  = pkg1::f(x)^2 + 5 * pkg1::f(x) + pkg2::g(y*2) * pkg1::f(x) + 6

步骤 3：排序（按总指数和字典序）
  - pkg1::f(x)^2                        (总指数2)
  - pkg2::g(y*2) * pkg1::f(x)          (总指数2，两个符号)
  - 5 * pkg1::f(x)                     (总指数1)
  - 6                                   (总指数0)

最终结果：
  pkg1::f(x)^2 + pkg1::f(x) * pkg2::g(y*2) + 5 * pkg1::f(x) + 6
  
注意：pkg1::f(x) * pkg2::g(y*2) 内部也按字典序排列
```

#### 示例 6：所有边界情况

```
输入表达式：
  1 * x + 0 * y + x * 1 * 1 + f(z) * 0 + 2 * 3 * a + x * x * x

步骤 1：化简每一项
  - 1 * x           → x           (省略1)
  - 0 * y           → 0           (消除)
  - x * 1 * 1       → x           (省略所有1)
  - f(z) * 0        → 0           (消除)
  - 2 * 3 * a       → 6 * a       (系数相乘)
  - x * x * x       → x^3         (幂次合并)

步骤 2：合并同类项
  - x + x           → 2 * x

步骤 3：排序
  - x^3             (总指数3)
  - 6 * a           (总指数1，'a' < 'x')
  - 2 * x           (总指数1)

最终结果：
  x^3 + 6 * a + 2 * x
```


## 实现细节

当前实现位于 `number/num_arithmetic.go`，核心步骤：
1. **词法分析（Tokenization）**：将表达式分解为 token
2. **语法分析（Parsing）**：构建 AST
3. **求值（Evaluation）**：展开多项式
4. **合并同类项（Simplify）**：合并并排序
5. **标准化输出**：按上述规则输出

排序算法的关键比较函数应该：
1. 先比较总指数（degree）
2. 总指数相同时，按变量的字典序比较
